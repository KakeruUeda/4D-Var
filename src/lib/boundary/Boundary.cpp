/**
 * @file Boundary.cpp
 * @author K.Ueda
 * @date May, 2024
 */

#include "Boundary.h"

/**
 * @brief Initialize dirichlet boundary.
 */
void Dirichlet::initialize(Config &conf)
{
  velocitySet = conf.vDirichlet;
  pressureSet = conf.pDirichlet;
}

/**
 * @brief Erase control nodes from velocitySet.
 *        This is used for solving adjoint matrix.
 */
void Dirichlet::eraseControlNodes(Cell &cell, ControlBoundary &cb)
{
  for(int in = 0; in < cb.CBNodeMap.size(); in++) {
    velocitySet.erase(cb.CBNodeMap[in]);
  }
}

void Dirichlet::setValuesZero(int n)
{
  values.allocate(n);
  initialValues.allocate(n);
  values.fillZero();
  initialValues.fillZero();
}

void Dirichlet::assignPulsatileBCs(const double pulse)
{
  for(auto &entry : velocitySet) {
    std::vector<double> &velocities = entry.second;

    velocities[0] = velocitySetInit[entry.first][0] * pulse;
    velocities[1] = velocitySetInit[entry.first][1] * pulse;
    velocities[2] = velocitySetInit[entry.first][2] * pulse;
  }
}

/**
 * @brief Initialize dirichlet boundary.
 */
void Dirichlet::getNewArray(std::vector<int> mapNew)
{
  for(const auto &[idx, values] : velocitySet) {
    int newIdx = mapNew[idx];
    velocitySetNew[newIdx] = values;
  }
  for(const auto &[idx, value] : pressureSet) {
    int newIdx = mapNew[idx];
    pressureSetNew[newIdx] = value;
  }
}

/**
 * @brief Assign dirichlet boundary conditions to dof array.
 */
void Dirichlet::assignBCs(Node &node)
{
  for(const auto &[idx, vec] : velocitySetNew) {
    for(int d = 0; d < 3; d++) {
      int dof = node.getDof(idx, d);
      values(dof) = vec[d];
    }
  }
  for(const auto &[idx, value] : pressureSetNew) {
    int dof = node.getDof(idx, 4);
    values(dof) = value;
  }
}

/**
 * @brief Set dirichlet boundary conditions.
 */
void Dirichlet::applyBCs(Cell &cell, PetscSolver &petsc)
{
  for(int ic = 0; ic < cell.nCellsGlobal; ic++) {
    if(cell(ic).subId == mpi.myId) {
      std::vector<int> vec = cell(ic).dofsMap;
      int nDofs = vec.size();

      MatrixXd Klocal(nDofs, nDofs);
      VectorXd Flocal(nDofs);

      Klocal.setZero();
      Flocal.setZero();

      for(int i = 0; i < nDofs; i++) {
        int dof = cell(ic).dofsMap[i];
        if(cell(ic).dofsBCsMap[i] == -1) {
          Klocal(i, i) = 1;
          Flocal(i) = values(dof);
        }
      }
      petsc.setMatValue(vec, vec, Klocal);
      petsc.setVecValue(vec, Flocal);
    }
  }

  petsc.flashAssembly();
}

/**
 * @brief Update dirichlet boundary conditions.
 */
void Dirichlet::updateValues(Array3D<double> &X, const int t)
{
  for(auto &[idx, vec] : velocitySet) {
    //if(vec[0] == 0 && vec[1] == 0 && vec[2] == 0) {
    //  continue;
    //}
    for(int d = 0; d < 3; d++) {
      vec[d] = X(t, idx, d);
    }
  }
}

constexpr Dirichlet::Velocity velArray[32] = {
    {0 * 0.02947812,  0.11943478},
    {1 * 0.02947812,  0.14436713},
    {2 * 0.02947812,  0.17000289},
    {3 * 0.02947812,  0.20747005},
    {4 * 0.02947812,  0.2368427 },
    {5 * 0.02947812,  0.26329655},
    {6 * 0.02947812,  0.26288376},
    {7 * 0.02947812,  0.25537007},
    {8 * 0.02947812,  0.25249323},
    {9 * 0.02947812,  0.24208209},
    {10 * 0.02947812, 0.22972814},
    {11 * 0.02947812, 0.19955092},
    {12 * 0.02947812, 0.17341562},
    {13 * 0.02947812, 0.147503  },
    {14 * 0.02947812, 0.12755212},
    {15 * 0.02947812, 0.11137679},
    {16 * 0.02947812, 0.08759725},
    {17 * 0.02947812, 0.07680825},
    {18 * 0.02947812, 0.08648109},
    {19 * 0.02947812, 0.09086978},
    {20 * 0.02947812, 0.07851191},
    {21 * 0.02947812, 0.06508125},
    {22 * 0.02947812, 0.05969055},
    {23 * 0.02947812, 0.0566123 },
    {24 * 0.02947812, 0.0549937 },
    {25 * 0.02947812, 0.05120174},
    {26 * 0.02947812, 0.04861119},
    {27 * 0.02947812, 0.05262863},
    {28 * 0.02947812, 0.05423519},
    {29 * 0.02947812, 0.04585582},
    {30 * 0.02947812, 0.05972958},
    {31 * 0.02947812, 0.06170865}
};

constexpr Dirichlet::Velocity MRI_inlet_vel_ave[32] = {
    {0 * 0.02947812,  0.119139   },
    {1 * 0.02947812,  0.144806   },
    {2 * 0.02947812,  0.18401    },
    {3 * 0.02947812,  0.227752   },
    {4 * 0.02947812,  0.271127   },
    {5 * 0.02947812,  0.295999   },
    {6 * 0.02947812,  0.303946   },
    {7 * 0.02947812,  0.307656   },
    {8 * 0.02947812,  0.305984   },
    {9 * 0.02947812,  0.296013   },
    {10 * 0.02947812, 0.277446   },
    {11 * 0.02947812, 0.249173   },
    {12 * 0.02947812, 0.212116   },
    {13 * 0.02947812, 0.178994   },
    {14 * 0.02947812, 0.153727   },
    {15 * 0.02947812, 0.115763   },
    {16 * 0.02947812, 0.0671914  },
    {17 * 0.02947812, 0.0568742  },
    {18 * 0.02947812, 0.0796945  },
    {19 * 0.02947812, 0.0777271  },
    {20 * 0.02947812, 0.0662676  },
    {21 * 0.02947812, 0.0481472  },
    {22 * 0.02947812, 0.0173611  },
    {23 * 0.02947812, -0.00184937},
    {24 * 0.02947812, -0.00103116},
    {25 * 0.02947812, -0.0018303 },
    {26 * 0.02947812, 0.00127949 },
    {27 * 0.02947812, 0.00303066 },
    {28 * 0.02947812, 0.0109009  },
    {29 * 0.02947812, 0.0202968  },
    {30 * 0.02947812, 0.0259528  },
    {31 * 0.02947812, 0.0385545  }
};

constexpr Dirichlet::Velocity MRI_flowRate_inlet_up_cycle1[32] = {
    {0 * 0.02947812,  5.04099e-05},
    {1 * 0.02947812,  6.09391e-05},
    {2 * 0.02947812,  7.71286e-05},
    {3 * 0.02947812,  9.46706e-05},
    {4 * 0.02947812,  0.000114585},
    {5 * 0.02947812,  0.000125831},
    {6 * 0.02947812,  0.000132091},
    {7 * 0.02947812,  0.00013697 },
    {8 * 0.02947812,  0.000138699},
    {9 * 0.02947812,  0.0001362  },
    {10 * 0.02947812, 0.000130106},
    {11 * 0.02947812, 0.000119685},
    {12 * 0.02947812, 0.000105362},
    {13 * 0.02947812, 9.19188e-05},
    {14 * 0.02947812, 8.124e-05  },
    {15 * 0.02947812, 6.50408e-05},
    {16 * 0.02947812, 4.45773e-05},
    {17 * 0.02947812, 3.67418e-05},
    {18 * 0.02947812, 4.35954e-05},
    {19 * 0.02947812, 4.30544e-05},
    {20 * 0.02947812, 3.80281e-05},
    {21 * 0.02947812, 2.95602e-05},
    {22 * 0.02947812, 1.68967e-05},
    {23 * 0.02947812, 6.5788e-06 },
    {24 * 0.02947812, 4.15306e-06},
    {25 * 0.02947812, 3.92779e-06},
    {26 * 0.02947812, 4.08175e-06},
    {27 * 0.02947812, 4.56967e-06},
    {28 * 0.02947812, 7.35374e-06},
    {29 * 0.02947812, 1.06075e-05},
    {30 * 0.02947812, 1.29749e-05},
    {31 * 0.02947812, 1.83048e-05}
};

constexpr Dirichlet::Velocity MRI_flowRate_inlet_up_cycle2[32] = {
    {32 * 0.02947812, 5.04099e-05},
    {33 * 0.02947812, 6.09391e-05},
    {34 * 0.02947812, 7.71286e-05},
    {35 * 0.02947812, 9.46706e-05},
    {36 * 0.02947812, 0.000114585},
    {37 * 0.02947812, 0.000125831},
    {38 * 0.02947812, 0.000132091},
    {39 * 0.02947812, 0.00013697 },
    {40 * 0.02947812, 0.000138699},
    {41 * 0.02947812, 0.0001362  },
    {42 * 0.02947812, 0.000130106},
    {43 * 0.02947812, 0.000119685},
    {44 * 0.02947812, 0.000105362},
    {45 * 0.02947812, 9.19188e-05},
    {46 * 0.02947812, 8.124e-05  },
    {47 * 0.02947812, 6.50408e-05},
    {48 * 0.02947812, 4.45773e-05},
    {49 * 0.02947812, 3.67418e-05},
    {50 * 0.02947812, 4.35954e-05},
    {51 * 0.02947812, 4.30544e-05},
    {52 * 0.02947812, 3.80281e-05},
    {53 * 0.02947812, 2.95602e-05},
    {54 * 0.02947812, 1.68967e-05},
    {55 * 0.02947812, 6.5788e-06 },
    {56 * 0.02947812, 4.15306e-06},
    {57 * 0.02947812, 3.92779e-06},
    {58 * 0.02947812, 4.08175e-06},
    {59 * 0.02947812, 4.56967e-06},
    {60 * 0.02947812, 7.35374e-06},
    {61 * 0.02947812, 1.06075e-05},
    {62 * 0.02947812, 1.29749e-05},
    {63 * 0.02947812, 1.83048e-05}
};

constexpr Dirichlet::Velocity MRI_flowRate_inlet_up_cycle3[32] = {
    {64 * 0.02947812, 5.04099e-05},
    {65 * 0.02947812, 6.09391e-05},
    {66 * 0.02947812, 7.71286e-05},
    {67 * 0.02947812, 9.46706e-05},
    {68 * 0.02947812, 0.000114585},
    {69 * 0.02947812, 0.000125831},
    {70 * 0.02947812, 0.000132091},
    {71 * 0.02947812, 0.00013697 },
    {72 * 0.02947812, 0.000138699},
    {73 * 0.02947812, 0.0001362  },
    {74 * 0.02947812, 0.000130106},
    {75 * 0.02947812, 0.000119685},
    {76 * 0.02947812, 0.000105362},
    {77 * 0.02947812, 9.19188e-05},
    {78 * 0.02947812, 8.124e-05  },
    {79 * 0.02947812, 6.50408e-05},
    {80 * 0.02947812, 4.45773e-05},
    {81 * 0.02947812, 3.67418e-05},
    {82 * 0.02947812, 4.35954e-05},
    {83 * 0.02947812, 4.30544e-05},
    {84 * 0.02947812, 3.80281e-05},
    {85 * 0.02947812, 2.95602e-05},
    {86 * 0.02947812, 1.68967e-05},
    {87 * 0.02947812, 6.5788e-06 },
    {88 * 0.02947812, 4.15306e-06},
    {89 * 0.02947812, 3.92779e-06},
    {90 * 0.02947812, 4.08175e-06},
    {91 * 0.02947812, 4.56967e-06},
    {92 * 0.02947812, 7.35374e-06},
    {93 * 0.02947812, 1.06075e-05},
    {94 * 0.02947812, 1.29749e-05},
    {95 * 0.02947812, 1.83048e-05}
};

constexpr Dirichlet::Velocity MRI_flowRate_inlet_cycle1[32] = {
    {0 * 0.02947812, 8.19497e-05},
    {1 * 0.02947812, 9.87376e-05},
    {2 * 0.02947812, 0.0001169},
    {3 * 0.02947812, 0.000144818},
    {4 * 0.02947812, 0.000168609},
    {5 * 0.02947812, 0.000164436},
    {6 * 0.02947812, 0.000141203},
    {7 * 0.02947812, 0.000113469},
    {8 * 0.02947812, 9.92508e-05},
    {9 * 0.02947812, 0.000151186},
    {10 * 0.02947812, 0.000165928},
    {11 * 0.02947812, 0.00014546},
    {12 * 0.02947812, 0.000116741},
    {13 * 0.02947812, 9.55508e-05},
    {14 * 0.02947812, 8.54617e-05},
    {15 * 0.02947812, 5.9945e-05},
    {16 * 0.02947812, 3.06439e-05},
    {17 * 0.02947812, 2.54524e-05},
    {18 * 0.02947812, 4.86887e-05},
    {19 * 0.02947812, 4.73371e-05},
    {20 * 0.02947812, 4.51723e-05},
    {21 * 0.02947812, 4.46956e-05},
    {22 * 0.02947812, 2.41156e-05},
    {23 * 0.02947812, 7.54683e-06},
    {24 * 0.02947812, 9.90298e-06},
    {25 * 0.02947812, 1.68993e-05},
    {26 * 0.02947812, 1.29723e-05},
    {27 * 0.02947812, 1.64261e-05},
    {28 * 0.02947812, 2.45174e-05},
    {29 * 0.02947812, 2.86522e-05},
    {30 * 0.02947812, 2.98064e-05},
    {31 * 0.02947812, 3.64669e-05}
};

constexpr Dirichlet::Velocity MRI_flowRate_inlet_cycle2[32] = {
    {32 * 0.02947812, 8.19497e-05},
    {33 * 0.02947812, 9.87376e-05},
    {34 * 0.02947812, 0.0001169},
    {35 * 0.02947812, 0.000144818},
    {36 * 0.02947812, 0.000168609},
    {37 * 0.02947812, 0.000164436},
    {38 * 0.02947812, 0.000141203},
    {39 * 0.02947812, 0.000113469},
    {40 * 0.02947812, 9.92508e-05},
    {41 * 0.02947812, 0.000151186},
    {42 * 0.02947812, 0.000165928},
    {43 * 0.02947812, 0.00014546},
    {44 * 0.02947812, 0.000116741},
    {45 * 0.02947812, 9.55508e-05},
    {46 * 0.02947812, 8.54617e-05},
    {47 * 0.02947812, 5.9945e-05},
    {48 * 0.02947812, 3.06439e-05},
    {49 * 0.02947812, 2.54524e-05},
    {50 * 0.02947812, 4.86887e-05},
    {51 * 0.02947812, 4.73371e-05},
    {52 * 0.02947812, 4.51723e-05},
    {53 * 0.02947812, 4.46956e-05},
    {54 * 0.02947812, 2.41156e-05},
    {55 * 0.02947812, 7.54683e-06},
    {56 * 0.02947812, 9.90298e-06},
    {57 * 0.02947812, 1.68993e-05},
    {58 * 0.02947812, 1.29723e-05},
    {59 * 0.02947812, 1.64261e-05},
    {60 * 0.02947812, 2.45174e-05},
    {61 * 0.02947812, 2.86522e-05},
    {62 * 0.02947812, 2.98064e-05},
    {63 * 0.02947812, 3.64669e-05}
};

constexpr Dirichlet::Velocity MRI_flowRate_inlet_cycle3[32] = {
    {64 * 0.02947812, 8.19497e-05},
    {65 * 0.02947812, 9.87376e-05},
    {66 * 0.02947812, 0.0001169},
    {67 * 0.02947812, 0.000144818},
    {68 * 0.02947812, 0.000168609},
    {69 * 0.02947812, 0.000164436},
    {70 * 0.02947812, 0.000141203},
    {71 * 0.02947812, 0.000113469},
    {72 * 0.02947812, 9.92508e-05},
    {73 * 0.02947812, 0.000151186},
    {74 * 0.02947812, 0.000165928},
    {75 * 0.02947812, 0.00014546},
    {76 * 0.02947812, 0.000116741},
    {77 * 0.02947812, 9.55508e-05},
    {78 * 0.02947812, 8.54617e-05},
    {79 * 0.02947812, 5.9945e-05},
    {80 * 0.02947812, 3.06439e-05},
    {81 * 0.02947812, 2.54524e-05},
    {82 * 0.02947812, 4.86887e-05},
    {83 * 0.02947812, 4.73371e-05},
    {84 * 0.02947812, 4.51723e-05},
    {85 * 0.02947812, 4.46956e-05},
    {86 * 0.02947812, 2.41156e-05},
    {87 * 0.02947812, 7.54683e-06},
    {88 * 0.02947812, 9.90298e-06},
    {89 * 0.02947812, 1.68993e-05},
    {90 * 0.02947812, 1.29723e-05},
    {91 * 0.02947812, 1.64261e-05},
    {92 * 0.02947812, 2.45174e-05},
    {93 * 0.02947812, 2.86522e-05},
    {94 * 0.02947812, 2.98064e-05},
    {95 * 0.02947812, 3.64669e-05}
};


constexpr Dirichlet::Velocity velArray2[16] = {
    {0 * 0.02947812,  0.11943478},
    {1 * 0.02947812,  0.14436713},
    {2 * 0.02947812,  0.17000289},
    {3 * 0.02947812,  0.20747005},
    {4 * 0.02947812,  0.2368427 },
    {5 * 0.02947812,  0.26329655},
    {6 * 0.02947812,  0.26288376},
    {7 * 0.02947812,  0.25537007},
    {8 * 0.02947812,  0.25249323},
    {9 * 0.02947812,  0.24208209},
    {10 * 0.02947812, 0.22972814},
    {11 * 0.02947812, 0.19955092},
    {12 * 0.02947812, 0.17341562},
    {13 * 0.02947812, 0.147503  },
    {14 * 0.02947812, 0.12755212},
    {15 * 0.02947812, 0.11137679}
};

double Dirichlet::comp_pulse(double timeNow)
{
  std::vector<double> x, y;

  for(int t = 0; t < 32; t++) {
    x.push_back(MRI_flowRate_inlet_cycle1[t].time);
    y.push_back(MRI_flowRate_inlet_cycle1[t].value);
  }
  for(int t = 0; t < 32; t++) {
    x.push_back(MRI_flowRate_inlet_cycle2[t].time);
    y.push_back(MRI_flowRate_inlet_cycle2[t].value);
  }
  for(int t = 0; t < 32; t++) {
    x.push_back(MRI_flowRate_inlet_cycle3[t].time);
    y.push_back(MRI_flowRate_inlet_cycle3[t].value);
  }

  vector<Spline::Coefficients> cf = Spline::compCoefficients(x, y);
  double pulse = Spline::evaluate(cf, timeNow);

  // double maxTime = MRI_flowRate_inlet_cycle3[31].time;
  // if(timeNow > maxTime) {
  //   if(mpi.myId == 0) {
  //     std::cout << "SimTime has completed three cycles. Exiting..." << std::endl;
  //   }
  //   MPI_Finalize();
  //   std::exit(0);
  // }

  // static double maxTime = MRI_flowRate_inlet[31].time;
  // static bool maxTimeUpdated = false;

  // if(timeNow > maxTime && !maxTimeUpdated) {
  //   maxTime = timeNow;
  //   maxTimeUpdated = true;
  // }

  // if(timeNow >= 3 * maxTime) {
  //   if(mpi.myId == 0) {
  //     std::cout << "SimTime has completed three cycles. Exiting..." << std::endl;
  //   }
  //   MPI_Finalize();
  //   std::exit(0);
  // }

  // double adjustedTime = std::fmod(timeNow, maxTime);
  // double pulse = Spline::evaluate(cf, adjustedTime);

  return pulse;
}

/**
 * @brief tmp.
 */
double Dirichlet::comp_pulse2(double timeNow, std::vector<std::array<double, 2>> &velArr)
{
  std::vector<double> x, y;

  for(const auto &arr : velArr) {
    x.push_back(arr[0]);
    y.push_back(arr[1]);
  }

  vector<Spline::Coefficients> cf = Spline::compCoefficients(x, y);

  double pulse = Spline::evaluate(cf, timeNow);
  return pulse;
}

/**
 * @brief Initialization.
 */
void ControlBoundary::initialize(Config &conf)
{
  CBNodeMap = std::move(conf.CBNodeMap);
  CBEdgeNodeMap = std::move(conf.CBEdgeNodeMap);
  CBCellMap = std::move(conf.CBCellMap);
  CBNodeMapInCell = std::move(conf.CBNodeMapInCell);
}
